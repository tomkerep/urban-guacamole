{
  "version": 3,
  "sources": ["../../solid-js/html/dist/html.js"],
  "sourcesContent": ["import {\r\n  effect,\r\n  style,\r\n  insert,\r\n  untrack,\r\n  spread,\r\n  createComponent,\r\n  delegateEvents,\r\n  classList,\r\n  mergeProps,\r\n  dynamicProperty,\r\n  setAttribute,\r\n  setAttributeNS,\r\n  addEventListener,\r\n  Aliases,\r\n  getPropAlias,\r\n  Properties,\r\n  ChildProperties,\r\n  DelegatedEvents,\r\n  SVGElements,\r\n  SVGNamespace\r\n} from \"solid-js/web\";\r\n\r\nconst tagRE = /(?:<!--[\\S\\s]*?-->|<(?:\"[^\"]*\"['\"]*|'[^']*'['\"]*|[^'\">])+>)/g;\r\nconst attrRE =\r\n  /(?:\\s(?<boolean>[^/\\s><=]+?)(?=[\\s/>]))|(?:(?<name>\\S+?)(?:\\s*=\\s*(?:(['\"])(?<quotedValue>[\\s\\S]*?)\\3|(?<unquotedValue>[^\\s>]+))))/g;\r\nconst lookup = {\r\n  area: true,\r\n  base: true,\r\n  br: true,\r\n  col: true,\r\n  embed: true,\r\n  hr: true,\r\n  img: true,\r\n  input: true,\r\n  keygen: true,\r\n  link: true,\r\n  menuitem: true,\r\n  meta: true,\r\n  param: true,\r\n  source: true,\r\n  track: true,\r\n  wbr: true\r\n};\r\nfunction parseTag(tag) {\r\n  const res = {\r\n    type: \"tag\",\r\n    name: \"\",\r\n    voidElement: false,\r\n    attrs: [],\r\n    children: []\r\n  };\r\n  const tagMatch = tag.match(/<\\/?([^\\s]+?)[/\\s>]/);\r\n  if (tagMatch) {\r\n    res.name = tagMatch[1];\r\n    if (lookup[tagMatch[1].toLowerCase()] || tag.charAt(tag.length - 2) === \"/\") {\r\n      res.voidElement = true;\r\n    }\r\n    if (res.name.startsWith(\"!--\")) {\r\n      const endIndex = tag.indexOf(\"-->\");\r\n      return {\r\n        type: \"comment\",\r\n        comment: endIndex !== -1 ? tag.slice(4, endIndex) : \"\"\r\n      };\r\n    }\r\n  }\r\n  const reg = new RegExp(attrRE);\r\n  for (const match of tag.matchAll(reg)) {\r\n    if ((match[1] || match[2]).startsWith(\"use:\")) {\r\n      res.attrs.push({\r\n        type: \"directive\",\r\n        name: match[1] || match[2],\r\n        value: match[4] || match[5] || \"\"\r\n      });\r\n    } else {\r\n      res.attrs.push({\r\n        type: \"attr\",\r\n        name: match[1] || match[2],\r\n        value: match[4] || match[5] || \"\"\r\n      });\r\n    }\r\n  }\r\n  return res;\r\n}\r\nfunction pushTextNode(list, html, start) {\r\n  const end = html.indexOf(\"<\", start);\r\n  const content = html.slice(start, end === -1 ? void 0 : end);\r\n  if (!/^\\s*$/.test(content)) {\r\n    list.push({\r\n      type: \"text\",\r\n      content: content\r\n    });\r\n  }\r\n}\r\nfunction pushCommentNode(list, tag) {\r\n  const content = tag.replace(\"<!--\", \"\").replace(\"-->\", \"\");\r\n  if (!/^\\s*$/.test(content)) {\r\n    list.push({\r\n      type: \"comment\",\r\n      content: content\r\n    });\r\n  }\r\n}\r\nfunction parse(html) {\r\n  const result = [];\r\n  let current = void 0;\r\n  let level = -1;\r\n  const arr = [];\r\n  const byTag = {};\r\n  html.replace(tagRE, (tag, index) => {\r\n    const isOpen = tag.charAt(1) !== \"/\";\r\n    const isComment = tag.slice(0, 4) === \"<!--\";\r\n    const start = index + tag.length;\r\n    const nextChar = html.charAt(start);\r\n    let parent = void 0;\r\n    if (isOpen && !isComment) {\r\n      level++;\r\n      current = parseTag(tag);\r\n      if (!current.voidElement && nextChar && nextChar !== \"<\") {\r\n        pushTextNode(current.children, html, start);\r\n      }\r\n      byTag[current.tagName] = current;\r\n      if (level === 0) {\r\n        result.push(current);\r\n      }\r\n      parent = arr[level - 1];\r\n      if (parent) {\r\n        parent.children.push(current);\r\n      }\r\n      arr[level] = current;\r\n    }\r\n    if (isComment) {\r\n      if (level < 0) {\r\n        pushCommentNode(result, tag);\r\n      } else {\r\n        pushCommentNode(arr[level].children, tag);\r\n      }\r\n    }\r\n    if (isComment || !isOpen || current.voidElement) {\r\n      if (!isComment) {\r\n        level--;\r\n      }\r\n      if (nextChar !== \"<\" && nextChar) {\r\n        parent = level === -1 ? result : arr[level].children;\r\n        pushTextNode(parent, html, start);\r\n      }\r\n    }\r\n  });\r\n  return result;\r\n}\r\nfunction attrString(attrs) {\r\n  const buff = [];\r\n  for (const attr of attrs) {\r\n    buff.push(attr.name + '=\"' + attr.value.replace(/\"/g, \"&quot;\") + '\"');\r\n  }\r\n  if (!buff.length) {\r\n    return \"\";\r\n  }\r\n  return \" \" + buff.join(\" \");\r\n}\r\nfunction stringifier(buff, doc) {\r\n  switch (doc.type) {\r\n    case \"text\":\r\n      return buff + doc.content;\r\n    case \"tag\":\r\n      buff +=\r\n        \"<\" + doc.name + (doc.attrs ? attrString(doc.attrs) : \"\") + (doc.voidElement ? \"/>\" : \">\");\r\n      if (doc.voidElement) {\r\n        return buff;\r\n      }\r\n      return buff + doc.children.reduce(stringifier, \"\") + \"</\" + doc.name + \">\";\r\n    case \"comment\":\r\n      return (buff += \"<!--\" + doc.content + \"-->\");\r\n  }\r\n}\r\nfunction stringify(doc) {\r\n  return doc.reduce(function (token, rootEl) {\r\n    return token + stringifier(\"\", rootEl);\r\n  }, \"\");\r\n}\r\nconst cache = new Map();\r\nconst VOID_ELEMENTS =\r\n  /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;\r\nconst spaces = \" \\\\f\\\\n\\\\r\\\\t\";\r\nconst almostEverything = \"[^\" + spaces + \"\\\\/>\\\"'=]+\";\r\nconst attrName = \"[ \" + spaces + \"]+(?:use:<!--#-->|\" + almostEverything + \")\";\r\nconst tagName = \"<([A-Za-z$#]+[A-Za-z0-9:_-]*)((?:\";\r\nconst attrPartials =\r\n  \"(?:\\\\s*=\\\\s*(?:'[^']*?'|\\\"[^\\\"]*?\\\"|\\\\([^)]*?\\\\)|<[^>]*?>|\" + almostEverything + \"))?)\";\r\nconst attrSeeker = new RegExp(tagName + attrName + attrPartials + \"+)([ \" + spaces + \"]*/?>)\", \"g\");\r\nconst findAttributes = new RegExp(\r\n  \"(\" + attrName + \"\\\\s*=\\\\s*)(<!--#-->|['\\\"(]([\\\\w\\\\s]*<!--#-->[\\\\w\\\\s]*)*['\\\")])\",\r\n  \"gi\"\r\n);\r\nconst selfClosing = new RegExp(tagName + attrName + attrPartials + \"*)([ \" + spaces + \"]*/>)\", \"g\");\r\nconst marker = \"<!--#-->\";\r\nconst reservedNameSpaces = new Set([\"class\", \"on\", \"oncapture\", \"style\", \"use\", \"prop\", \"attr\"]);\r\nfunction attrReplacer($0, $1, $2, $3) {\r\n  return \"<\" + $1 + $2.replace(findAttributes, replaceAttributes) + $3;\r\n}\r\nfunction replaceAttributes($0, $1, $2) {\r\n  return (\r\n    $1.replace(/<!--#-->/g, \"###\") +\r\n    ($2[0] === '\"' || $2[0] === \"'\" ? $2.replace(/<!--#-->/g, \"###\") : '\"###\"')\r\n  );\r\n}\r\nfunction fullClosing($0, $1, $2) {\r\n  return VOID_ELEMENTS.test($1) ? $0 : \"<\" + $1 + $2 + \"></\" + $1 + \">\";\r\n}\r\nfunction toPropertyName(name) {\r\n  return name.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());\r\n}\r\nfunction parseDirective(name, value, tag, options) {\r\n  if (name === \"use:###\" && value === \"###\") {\r\n    const count = options.counter++;\r\n    options.exprs.push(\r\n      `typeof exprs[${count}] === \"function\" ? r.use(exprs[${count}], ${tag}, exprs[${options.counter++}]) : (()=>{throw new Error(\"use:### must be a function\")})()`\r\n    );\r\n  } else {\r\n    throw new Error(`Not support syntax ${name} must be use:{function}`);\r\n  }\r\n}\r\nfunction createHTML(\r\n  r,\r\n  { delegateEvents = true, functionBuilder = (...args) => new Function(...args) } = {}\r\n) {\r\n  let uuid = 1;\r\n  r.wrapProps = props => {\r\n    const d = Object.getOwnPropertyDescriptors(props);\r\n    for (const k in d) {\r\n      if (typeof d[k].value === \"function\" && !d[k].value.length) r.dynamicProperty(props, k);\r\n    }\r\n    return props;\r\n  };\r\n  function createTemplate(statics, opt) {\r\n    let i = 0,\r\n      markup = \"\";\r\n    for (; i < statics.length - 1; i++) {\r\n      markup = markup + statics[i] + \"<!--#-->\";\r\n    }\r\n    markup = markup + statics[i];\r\n    const replaceList = [\r\n      [selfClosing, fullClosing],\r\n      [/<(<!--#-->)/g, \"<###\"],\r\n      [/\\.\\.\\.(<!--#-->)/g, \"###\"],\r\n      [attrSeeker, attrReplacer],\r\n      [/>\\n+\\s*/g, \">\"],\r\n      [/\\n+\\s*</g, \"<\"],\r\n      [/\\s+</g, \" <\"],\r\n      [/>\\s+/g, \"> \"]\r\n    ];\r\n    markup = replaceList.reduce((acc, x) => {\r\n      return acc.replace(x[0], x[1]);\r\n    }, markup);\r\n    const pars = parse(markup);\r\n    const [html, code] = parseTemplate(pars, opt.funcBuilder),\r\n      templates = [];\r\n    for (let i = 0; i < html.length; i++) {\r\n      templates.push(document.createElement(\"template\"));\r\n      templates[i].innerHTML = html[i];\r\n      const nomarkers = templates[i].content.querySelectorAll(\"script,style\");\r\n      for (let j = 0; j < nomarkers.length; j++) {\r\n        const d = nomarkers[j].firstChild?.data || \"\";\r\n        if (d.indexOf(marker) > -1) {\r\n          const parts = d.split(marker).reduce((memo, p, i) => {\r\n            i && memo.push(\"\");\r\n            memo.push(p);\r\n            return memo;\r\n          }, []);\r\n          nomarkers[i].firstChild.replaceWith(...parts);\r\n        }\r\n      }\r\n    }\r\n    templates[0].create = code;\r\n    cache.set(statics, templates);\r\n    return templates;\r\n  }\r\n  function parseKeyValue(node, tag, name, value, isSVG, isCE, options) {\r\n    let expr =\r\n        value === \"###\"\r\n          ? `!doNotWrap ? exprs[${options.counter}]() : exprs[${options.counter++}]`\r\n          : value\r\n              .split(\"###\")\r\n              .map((v, i) =>\r\n                i\r\n                  ? ` + (typeof exprs[${options.counter}] === \"function\" ? exprs[${\r\n                      options.counter\r\n                    }]() : exprs[${options.counter++}]) + \"${v}\"`\r\n                  : `\"${v}\"`\r\n              )\r\n              .join(\"\"),\r\n      parts,\r\n      namespace;\r\n    if ((parts = name.split(\":\")) && parts[1] && reservedNameSpaces.has(parts[0])) {\r\n      name = parts[1];\r\n      namespace = parts[0];\r\n    }\r\n    const isChildProp = r.ChildProperties.has(name);\r\n    const isProp = r.Properties.has(name);\r\n    if (name === \"style\") {\r\n      const prev = `_$v${uuid++}`;\r\n      options.decl.push(`${prev}={}`);\r\n      options.exprs.push(`r.style(${tag},${expr},${prev})`);\r\n    } else if (name === \"classList\") {\r\n      const prev = `_$v${uuid++}`;\r\n      options.decl.push(`${prev}={}`);\r\n      options.exprs.push(`r.classList(${tag},${expr},${prev})`);\r\n    } else if (\r\n      namespace !== \"attr\" &&\r\n      (isChildProp ||\r\n        (!isSVG && (r.getPropAlias(name, node.name.toUpperCase()) || isProp)) ||\r\n        isCE ||\r\n        namespace === \"prop\")\r\n    ) {\r\n      if (isCE && !isChildProp && !isProp && namespace !== \"prop\") name = toPropertyName(name);\r\n      options.exprs.push(\r\n        `${tag}.${r.getPropAlias(name, node.name.toUpperCase()) || name} = ${expr}`\r\n      );\r\n    } else {\r\n      const ns = isSVG && name.indexOf(\":\") > -1 && r.SVGNamespace[name.split(\":\")[0]];\r\n      if (ns) options.exprs.push(`r.setAttributeNS(${tag},\"${ns}\",\"${name}\",${expr})`);\r\n      else options.exprs.push(`r.setAttribute(${tag},\"${r.Aliases[name] || name}\",${expr})`);\r\n    }\r\n  }\r\n  function parseAttribute(node, tag, name, value, isSVG, isCE, options) {\r\n    if (name.slice(0, 2) === \"on\") {\r\n      if (!name.includes(\":\")) {\r\n        const lc = name.slice(2).toLowerCase();\r\n        const delegate = delegateEvents && r.DelegatedEvents.has(lc);\r\n        options.exprs.push(\r\n          `r.addEventListener(${tag},\"${lc}\",exprs[${options.counter++}],${delegate})`\r\n        );\r\n        delegate && options.delegatedEvents.add(lc);\r\n      } else {\r\n        let capture = name.startsWith(\"oncapture:\");\r\n        options.exprs.push(\r\n          `${tag}.addEventListener(\"${name.slice(capture ? 10 : 3)}\",exprs[${options.counter++}]${\r\n            capture ? \",true\" : \"\"\r\n          })`\r\n        );\r\n      }\r\n    } else if (name === \"ref\") {\r\n      options.exprs.push(`exprs[${options.counter++}](${tag})`);\r\n    } else {\r\n      const childOptions = Object.assign({}, options, {\r\n          exprs: []\r\n        }),\r\n        count = options.counter;\r\n      parseKeyValue(node, tag, name, value, isSVG, isCE, childOptions);\r\n      options.decl.push(\r\n        `_fn${count} = (${value === \"###\" ? \"doNotWrap\" : \"\"}) => {\\n${childOptions.exprs.join(\r\n          \";\\n\"\r\n        )};\\n}`\r\n      );\r\n      if (value === \"###\") {\r\n        options.exprs.push(\r\n          `typeof exprs[${count}] === \"function\" ? r.effect(_fn${count}) : _fn${count}(true)`\r\n        );\r\n      } else {\r\n        let check = \"\";\r\n        for (let i = count; i < childOptions.counter; i++) {\r\n          i !== count && (check += \" || \");\r\n          check += `typeof exprs[${i}] === \"function\"`;\r\n        }\r\n        options.exprs.push(check + ` ? r.effect(_fn${count}) : _fn${count}()`);\r\n      }\r\n      options.counter = childOptions.counter;\r\n      options.wrap = false;\r\n    }\r\n  }\r\n  function processChildren(node, options) {\r\n    const childOptions = Object.assign({}, options, {\r\n      first: true,\r\n      multi: false,\r\n      parent: options.path\r\n    });\r\n    if (node.children.length > 1) {\r\n      for (let i = 0; i < node.children.length; i++) {\r\n        const child = node.children[i];\r\n        if (\r\n          (child.type === \"comment\" && child.content === \"#\") ||\r\n          (child.type === \"tag\" && child.name === \"###\")\r\n        ) {\r\n          childOptions.multi = true;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    let i = 0;\r\n    while (i < node.children.length) {\r\n      const child = node.children[i];\r\n      if (child.name === \"###\") {\r\n        if (childOptions.multi) {\r\n          node.children[i] = {\r\n            type: \"comment\",\r\n            content: \"#\"\r\n          };\r\n          i++;\r\n        } else node.children.splice(i, 1);\r\n        processComponent(child, childOptions);\r\n        continue;\r\n      }\r\n      parseNode(child, childOptions);\r\n      if (!childOptions.multi && child.type === \"comment\" && child.content === \"#\")\r\n        node.children.splice(i, 1);\r\n      else i++;\r\n    }\r\n    options.counter = childOptions.counter;\r\n    options.templateId = childOptions.templateId;\r\n    options.hasCustomElement = options.hasCustomElement || childOptions.hasCustomElement;\r\n  }\r\n  function processComponentProps(propGroups) {\r\n    let result = [];\r\n    for (const props of propGroups) {\r\n      if (Array.isArray(props)) {\r\n        if (!props.length) continue;\r\n        result.push(`r.wrapProps({${props.join(\",\") || \"\"}})`);\r\n      } else result.push(props);\r\n    }\r\n    return result.length > 1 ? `r.mergeProps(${result.join(\",\")})` : result[0];\r\n  }\r\n  function processComponent(node, options) {\r\n    let props = [];\r\n    const keys = Object.keys(node.attrs),\r\n      propGroups = [props],\r\n      componentIdentifier = options.counter++;\r\n    for (let i = 0; i < keys.length; i++) {\r\n      const { type, name, value } = node.attrs[i];\r\n      if (type === \"attr\") {\r\n        if (name === \"###\") {\r\n          propGroups.push(`exprs[${options.counter++}]`);\r\n          propGroups.push((props = []));\r\n        } else if (value === \"###\") {\r\n          props.push(`${name}: exprs[${options.counter++}]`);\r\n        } else props.push(`${name}: \"${value}\"`);\r\n      } else if (type === \"directive\") {\r\n        const tag = `_$el${uuid++}`;\r\n        const topDecl = !options.decl.length;\r\n        options.decl.push(\r\n          topDecl ? \"\" : `${tag} = ${options.path}.${options.first ? \"firstChild\" : \"nextSibling\"}`\r\n        );\r\n        parseDirective(name, value, tag, options);\r\n      }\r\n    }\r\n    if (\r\n      node.children.length === 1 &&\r\n      node.children[0].type === \"comment\" &&\r\n      node.children[0].content === \"#\"\r\n    ) {\r\n      props.push(`children: () => exprs[${options.counter++}]`);\r\n    } else if (node.children.length) {\r\n      const children = {\r\n          type: \"fragment\",\r\n          children: node.children\r\n        },\r\n        childOptions = Object.assign({}, options, {\r\n          first: true,\r\n          decl: [],\r\n          exprs: [],\r\n          parent: false\r\n        });\r\n      parseNode(children, childOptions);\r\n      props.push(`children: () => { ${childOptions.exprs.join(\";\\n\")}}`);\r\n      options.templateId = childOptions.templateId;\r\n      options.counter = childOptions.counter;\r\n    }\r\n    let tag;\r\n    if (options.multi) {\r\n      tag = `_$el${uuid++}`;\r\n      options.decl.push(`${tag} = ${options.path}.${options.first ? \"firstChild\" : \"nextSibling\"}`);\r\n    }\r\n    if (options.parent)\r\n      options.exprs.push(\r\n        `r.insert(${\r\n          options.parent\r\n        }, r.createComponent(exprs[${componentIdentifier}],${processComponentProps(propGroups)})${\r\n          tag ? `, ${tag}` : \"\"\r\n        })`\r\n      );\r\n    else\r\n      options.exprs.push(\r\n        `${\r\n          options.fragment ? \"\" : \"return \"\r\n        }r.createComponent(exprs[${componentIdentifier}],${processComponentProps(propGroups)})`\r\n      );\r\n    options.path = tag;\r\n    options.first = false;\r\n  }\r\n  function parseNode(node, options) {\r\n    if (node.type === \"fragment\") {\r\n      const parts = [];\r\n      node.children.forEach(child => {\r\n        if (child.type === \"tag\") {\r\n          if (child.name === \"###\") {\r\n            const childOptions = Object.assign({}, options, {\r\n              first: true,\r\n              fragment: true,\r\n              decl: [],\r\n              exprs: []\r\n            });\r\n            processComponent(child, childOptions);\r\n            parts.push(childOptions.exprs[0]);\r\n            options.counter = childOptions.counter;\r\n            options.templateId = childOptions.templateId;\r\n            return;\r\n          }\r\n          options.templateId++;\r\n          const id = uuid;\r\n          const childOptions = Object.assign({}, options, {\r\n            first: true,\r\n            decl: [],\r\n            exprs: []\r\n          });\r\n          options.templateNodes.push([child]);\r\n          parseNode(child, childOptions);\r\n          parts.push(\r\n            `function() { ${\r\n              childOptions.decl.join(\",\\n\") +\r\n              \";\\n\" +\r\n              childOptions.exprs.join(\";\\n\") +\r\n              `;\\nreturn _$el${id};\\n`\r\n            }}()`\r\n          );\r\n          options.counter = childOptions.counter;\r\n          options.templateId = childOptions.templateId;\r\n        } else if (child.type === \"text\") {\r\n          parts.push(`\"${child.content}\"`);\r\n        } else if (child.type === \"comment\") {\r\n          if (child.content === \"#\") parts.push(`exprs[${options.counter++}]`);\r\n          else if (child.content) {\r\n            for (let i = 0; i < child.content.split(\"###\").length - 1; i++) {\r\n              parts.push(`exprs[${options.counter++}]`);\r\n            }\r\n          }\r\n        }\r\n      });\r\n      options.exprs.push(`return [${parts.join(\", \\n\")}]`);\r\n    } else if (node.type === \"tag\") {\r\n      const tag = `_$el${uuid++}`;\r\n      const topDecl = !options.decl.length;\r\n      const templateId = options.templateId;\r\n      options.decl.push(\r\n        topDecl ? \"\" : `${tag} = ${options.path}.${options.first ? \"firstChild\" : \"nextSibling\"}`\r\n      );\r\n      const isSVG = r.SVGElements.has(node.name);\r\n      const isCE = node.name.includes(\"-\");\r\n      options.hasCustomElement = isCE;\r\n      if (node.attrs.some(e => e.name === \"###\")) {\r\n        const spreadArgs = [];\r\n        let current = \"\";\r\n        const newAttrs = [];\r\n        for (let i = 0; i < node.attrs.length; i++) {\r\n          const { type, name, value } = node.attrs[i];\r\n          if (type === \"attr\") {\r\n            if (value.includes(\"###\")) {\r\n              let count = options.counter++;\r\n              current += `${name}: ${\r\n                name !== \"ref\" ? `typeof exprs[${count}] === \"function\" ? exprs[${count}]() : ` : \"\"\r\n              }exprs[${count}],`;\r\n            } else if (name === \"###\") {\r\n              if (current.length) {\r\n                spreadArgs.push(`()=>({${current}})`);\r\n                current = \"\";\r\n              }\r\n              spreadArgs.push(`exprs[${options.counter++}]`);\r\n            } else {\r\n              newAttrs.push(node.attrs[i]);\r\n            }\r\n          } else if (type === \"directive\") {\r\n            parseDirective(name, value, tag, options);\r\n          }\r\n        }\r\n        node.attrs = newAttrs;\r\n        if (current.length) {\r\n          spreadArgs.push(`()=>({${current}})`);\r\n        }\r\n        options.exprs.push(\r\n          `r.spread(${tag},${\r\n            spreadArgs.length === 1\r\n              ? `typeof ${spreadArgs[0]} === \"function\" ? r.mergeProps(${spreadArgs[0]}) : ${spreadArgs[0]}`\r\n              : `r.mergeProps(${spreadArgs.join(\",\")})`\r\n          },${isSVG},${!!node.children.length})`\r\n        );\r\n      } else {\r\n        for (let i = 0; i < node.attrs.length; i++) {\r\n          const { type, name, value } = node.attrs[i];\r\n          if (type === \"directive\") {\r\n            parseDirective(name, value, tag, options);\r\n            node.attrs.splice(i, 1);\r\n            i--;\r\n          } else if (type === \"attr\") {\r\n            if (value.includes(\"###\")) {\r\n              node.attrs.splice(i, 1);\r\n              i--;\r\n              parseAttribute(node, tag, name, value, isSVG, isCE, options);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      options.path = tag;\r\n      options.first = false;\r\n      processChildren(node, options);\r\n      if (topDecl) {\r\n        options.decl[0] = options.hasCustomElement\r\n          ? `const ${tag} = r.untrack(() => document.importNode(tmpls[${templateId}].content.firstChild, true))`\r\n          : `const ${tag} = tmpls[${templateId}].content.firstChild.cloneNode(true)`;\r\n      }\r\n    } else if (node.type === \"text\") {\r\n      const tag = `_$el${uuid++}`;\r\n      options.decl.push(`${tag} = ${options.path}.${options.first ? \"firstChild\" : \"nextSibling\"}`);\r\n      options.path = tag;\r\n      options.first = false;\r\n    } else if (node.type === \"comment\") {\r\n      const tag = `_$el${uuid++}`;\r\n      options.decl.push(`${tag} = ${options.path}.${options.first ? \"firstChild\" : \"nextSibling\"}`);\r\n      if (node.content === \"#\") {\r\n        if (options.multi) {\r\n          options.exprs.push(`r.insert(${options.parent}, exprs[${options.counter++}], ${tag})`);\r\n        } else options.exprs.push(`r.insert(${options.parent}, exprs[${options.counter++}])`);\r\n      }\r\n      options.path = tag;\r\n      options.first = false;\r\n    }\r\n  }\r\n  function parseTemplate(nodes, funcBuilder) {\r\n    const options = {\r\n        path: \"\",\r\n        decl: [],\r\n        exprs: [],\r\n        delegatedEvents: new Set(),\r\n        counter: 0,\r\n        first: true,\r\n        multi: false,\r\n        templateId: 0,\r\n        templateNodes: []\r\n      },\r\n      id = uuid,\r\n      origNodes = nodes;\r\n    let toplevel;\r\n    if (nodes.length > 1) {\r\n      nodes = [\r\n        {\r\n          type: \"fragment\",\r\n          children: nodes\r\n        }\r\n      ];\r\n    }\r\n    if (nodes[0].name === \"###\") {\r\n      toplevel = true;\r\n      processComponent(nodes[0], options);\r\n    } else parseNode(nodes[0], options);\r\n    r.delegateEvents(Array.from(options.delegatedEvents));\r\n    const templateNodes = [origNodes].concat(options.templateNodes);\r\n    return [\r\n      templateNodes.map(t => stringify(t)),\r\n      funcBuilder(\r\n        \"tmpls\",\r\n        \"exprs\",\r\n        \"r\",\r\n        options.decl.join(\",\\n\") +\r\n          \";\\n\" +\r\n          options.exprs.join(\";\\n\") +\r\n          (toplevel ? \"\" : `;\\nreturn _$el${id};\\n`)\r\n      )\r\n    ];\r\n  }\r\n  function html(statics, ...args) {\r\n    const templates =\r\n      cache.get(statics) ||\r\n      createTemplate(statics, {\r\n        funcBuilder: functionBuilder\r\n      });\r\n    return templates[0].create(templates, args, r);\r\n  }\r\n  return html;\r\n}\r\n\r\nconst html = createHTML({\r\n  effect,\r\n  style,\r\n  insert,\r\n  untrack,\r\n  spread,\r\n  createComponent,\r\n  delegateEvents,\r\n  classList,\r\n  mergeProps,\r\n  dynamicProperty,\r\n  setAttribute,\r\n  setAttributeNS,\r\n  addEventListener,\r\n  Aliases,\r\n  getPropAlias,\r\n  Properties,\r\n  ChildProperties,\r\n  DelegatedEvents,\r\n  SVGElements,\r\n  SVGNamespace\r\n});\r\n\r\nexport { html as default };\r\n"],
  "mappings": "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",
  "names": ["html", "delegateEvents", "i", "tag", "childOptions"]
}
