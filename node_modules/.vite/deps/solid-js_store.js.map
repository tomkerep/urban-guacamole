{
  "version": 3,
  "sources": ["../../solid-js/store/dist/dev.js"],
  "sourcesContent": ["import { DEV as DEV$1, $PROXY, $TRACK, getListener, batch, createSignal } from \"solid-js\";\r\n\r\nconst $RAW = Symbol(\"store-raw\"),\r\n  $NODE = Symbol(\"store-node\"),\r\n  $HAS = Symbol(\"store-has\"),\r\n  $SELF = Symbol(\"store-self\");\r\nconst DevHooks = {\r\n  onStoreNodeUpdate: null\r\n};\r\nfunction wrap$1(value) {\r\n  let p = value[$PROXY];\r\n  if (!p) {\r\n    Object.defineProperty(value, $PROXY, {\r\n      value: (p = new Proxy(value, proxyTraps$1))\r\n    });\r\n    if (!Array.isArray(value)) {\r\n      const keys = Object.keys(value),\r\n        desc = Object.getOwnPropertyDescriptors(value);\r\n      for (let i = 0, l = keys.length; i < l; i++) {\r\n        const prop = keys[i];\r\n        if (desc[prop].get) {\r\n          Object.defineProperty(value, prop, {\r\n            enumerable: desc[prop].enumerable,\r\n            get: desc[prop].get.bind(p)\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return p;\r\n}\r\nfunction isWrappable(obj) {\r\n  let proto;\r\n  return (\r\n    obj != null &&\r\n    typeof obj === \"object\" &&\r\n    (obj[$PROXY] ||\r\n      !(proto = Object.getPrototypeOf(obj)) ||\r\n      proto === Object.prototype ||\r\n      Array.isArray(obj))\r\n  );\r\n}\r\nfunction unwrap(item, set = new Set()) {\r\n  let result, unwrapped, v, prop;\r\n  if ((result = item != null && item[$RAW])) return result;\r\n  if (!isWrappable(item) || set.has(item)) return item;\r\n  if (Array.isArray(item)) {\r\n    if (Object.isFrozen(item)) item = item.slice(0);\r\n    else set.add(item);\r\n    for (let i = 0, l = item.length; i < l; i++) {\r\n      v = item[i];\r\n      if ((unwrapped = unwrap(v, set)) !== v) item[i] = unwrapped;\r\n    }\r\n  } else {\r\n    if (Object.isFrozen(item)) item = Object.assign({}, item);\r\n    else set.add(item);\r\n    const keys = Object.keys(item),\r\n      desc = Object.getOwnPropertyDescriptors(item);\r\n    for (let i = 0, l = keys.length; i < l; i++) {\r\n      prop = keys[i];\r\n      if (desc[prop].get) continue;\r\n      v = item[prop];\r\n      if ((unwrapped = unwrap(v, set)) !== v) item[prop] = unwrapped;\r\n    }\r\n  }\r\n  return item;\r\n}\r\nfunction getNodes(target, symbol) {\r\n  let nodes = target[symbol];\r\n  if (!nodes)\r\n    Object.defineProperty(target, symbol, {\r\n      value: (nodes = Object.create(null))\r\n    });\r\n  return nodes;\r\n}\r\nfunction getNode(nodes, property, value) {\r\n  if (nodes[property]) return nodes[property];\r\n  const [s, set] = createSignal(value, {\r\n    equals: false,\r\n    internal: true\r\n  });\r\n  s.$ = set;\r\n  return (nodes[property] = s);\r\n}\r\nfunction proxyDescriptor$1(target, property) {\r\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\r\n  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE)\r\n    return desc;\r\n  delete desc.value;\r\n  delete desc.writable;\r\n  desc.get = () => target[$PROXY][property];\r\n  return desc;\r\n}\r\nfunction trackSelf(target) {\r\n  getListener() && getNode(getNodes(target, $NODE), $SELF)();\r\n}\r\nfunction ownKeys(target) {\r\n  trackSelf(target);\r\n  return Reflect.ownKeys(target);\r\n}\r\nconst proxyTraps$1 = {\r\n  get(target, property, receiver) {\r\n    if (property === $RAW) return target;\r\n    if (property === $PROXY) return receiver;\r\n    if (property === $TRACK) {\r\n      trackSelf(target);\r\n      return receiver;\r\n    }\r\n    const nodes = getNodes(target, $NODE);\r\n    const tracked = nodes[property];\r\n    let value = tracked ? tracked() : target[property];\r\n    if (property === $NODE || property === $HAS || property === \"__proto__\") return value;\r\n    if (!tracked) {\r\n      const desc = Object.getOwnPropertyDescriptor(target, property);\r\n      if (\r\n        getListener() &&\r\n        (typeof value !== \"function\" || target.hasOwnProperty(property)) &&\r\n        !(desc && desc.get)\r\n      )\r\n        value = getNode(nodes, property, value)();\r\n    }\r\n    return isWrappable(value) ? wrap$1(value) : value;\r\n  },\r\n  has(target, property) {\r\n    if (\r\n      property === $RAW ||\r\n      property === $PROXY ||\r\n      property === $TRACK ||\r\n      property === $NODE ||\r\n      property === $HAS ||\r\n      property === \"__proto__\"\r\n    )\r\n      return true;\r\n    getListener() && getNode(getNodes(target, $HAS), property)();\r\n    return property in target;\r\n  },\r\n  set() {\r\n    console.warn(\"Cannot mutate a Store directly\");\r\n    return true;\r\n  },\r\n  deleteProperty() {\r\n    console.warn(\"Cannot mutate a Store directly\");\r\n    return true;\r\n  },\r\n  ownKeys: ownKeys,\r\n  getOwnPropertyDescriptor: proxyDescriptor$1\r\n};\r\nfunction setProperty(state, property, value, deleting = false) {\r\n  if (!deleting && state[property] === value) return;\r\n  const prev = state[property],\r\n    len = state.length;\r\n  DevHooks.onStoreNodeUpdate && DevHooks.onStoreNodeUpdate(state, property, value, prev);\r\n  if (value === undefined) {\r\n    delete state[property];\r\n    if (state[$HAS] && state[$HAS][property] && prev !== undefined) state[$HAS][property].$();\r\n  } else {\r\n    state[property] = value;\r\n    if (state[$HAS] && state[$HAS][property] && prev === undefined) state[$HAS][property].$();\r\n  }\r\n  let nodes = getNodes(state, $NODE),\r\n    node;\r\n  if ((node = getNode(nodes, property, prev))) node.$(() => value);\r\n  if (Array.isArray(state) && state.length !== len) {\r\n    for (let i = state.length; i < len; i++) (node = nodes[i]) && node.$();\r\n    (node = getNode(nodes, \"length\", len)) && node.$(state.length);\r\n  }\r\n  (node = nodes[$SELF]) && node.$();\r\n}\r\nfunction mergeStoreNode(state, value) {\r\n  const keys = Object.keys(value);\r\n  for (let i = 0; i < keys.length; i += 1) {\r\n    const key = keys[i];\r\n    setProperty(state, key, value[key]);\r\n  }\r\n}\r\nfunction updateArray(current, next) {\r\n  if (typeof next === \"function\") next = next(current);\r\n  next = unwrap(next);\r\n  if (Array.isArray(next)) {\r\n    if (current === next) return;\r\n    let i = 0,\r\n      len = next.length;\r\n    for (; i < len; i++) {\r\n      const value = next[i];\r\n      if (current[i] !== value) setProperty(current, i, value);\r\n    }\r\n    setProperty(current, \"length\", len);\r\n  } else mergeStoreNode(current, next);\r\n}\r\nfunction updatePath(current, path, traversed = []) {\r\n  let part,\r\n    prev = current;\r\n  if (path.length > 1) {\r\n    part = path.shift();\r\n    const partType = typeof part,\r\n      isArray = Array.isArray(current);\r\n    if (Array.isArray(part)) {\r\n      for (let i = 0; i < part.length; i++) {\r\n        updatePath(current, [part[i]].concat(path), traversed);\r\n      }\r\n      return;\r\n    } else if (isArray && partType === \"function\") {\r\n      for (let i = 0; i < current.length; i++) {\r\n        if (part(current[i], i)) updatePath(current, [i].concat(path), traversed);\r\n      }\r\n      return;\r\n    } else if (isArray && partType === \"object\") {\r\n      const { from = 0, to = current.length - 1, by = 1 } = part;\r\n      for (let i = from; i <= to; i += by) {\r\n        updatePath(current, [i].concat(path), traversed);\r\n      }\r\n      return;\r\n    } else if (path.length > 1) {\r\n      updatePath(current[part], path, [part].concat(traversed));\r\n      return;\r\n    }\r\n    prev = current[part];\r\n    traversed = [part].concat(traversed);\r\n  }\r\n  let value = path[0];\r\n  if (typeof value === \"function\") {\r\n    value = value(prev, traversed);\r\n    if (value === prev) return;\r\n  }\r\n  if (part === undefined && value == undefined) return;\r\n  value = unwrap(value);\r\n  if (part === undefined || (isWrappable(prev) && isWrappable(value) && !Array.isArray(value))) {\r\n    mergeStoreNode(prev, value);\r\n  } else setProperty(current, part, value);\r\n}\r\nfunction createStore(...[store, options]) {\r\n  const unwrappedStore = unwrap(store || {});\r\n  const isArray = Array.isArray(unwrappedStore);\r\n  if (typeof unwrappedStore !== \"object\" && typeof unwrappedStore !== \"function\")\r\n    throw new Error(\r\n      `Unexpected type ${typeof unwrappedStore} received when initializing 'createStore'. Expected an object.`\r\n    );\r\n  const wrappedStore = wrap$1(unwrappedStore);\r\n  DEV$1.registerGraph({\r\n    value: unwrappedStore,\r\n    name: options && options.name\r\n  });\r\n  function setStore(...args) {\r\n    batch(() => {\r\n      isArray && args.length === 1\r\n        ? updateArray(unwrappedStore, args[0])\r\n        : updatePath(unwrappedStore, args);\r\n    });\r\n  }\r\n  return [wrappedStore, setStore];\r\n}\r\n\r\nfunction proxyDescriptor(target, property) {\r\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\r\n  if (\r\n    !desc ||\r\n    desc.get ||\r\n    desc.set ||\r\n    !desc.configurable ||\r\n    property === $PROXY ||\r\n    property === $NODE\r\n  )\r\n    return desc;\r\n  delete desc.value;\r\n  delete desc.writable;\r\n  desc.get = () => target[$PROXY][property];\r\n  desc.set = v => (target[$PROXY][property] = v);\r\n  return desc;\r\n}\r\nconst proxyTraps = {\r\n  get(target, property, receiver) {\r\n    if (property === $RAW) return target;\r\n    if (property === $PROXY) return receiver;\r\n    if (property === $TRACK) {\r\n      trackSelf(target);\r\n      return receiver;\r\n    }\r\n    const nodes = getNodes(target, $NODE);\r\n    const tracked = nodes[property];\r\n    let value = tracked ? tracked() : target[property];\r\n    if (property === $NODE || property === $HAS || property === \"__proto__\") return value;\r\n    if (!tracked) {\r\n      const desc = Object.getOwnPropertyDescriptor(target, property);\r\n      const isFunction = typeof value === \"function\";\r\n      if (getListener() && (!isFunction || target.hasOwnProperty(property)) && !(desc && desc.get))\r\n        value = getNode(nodes, property, value)();\r\n      else if (value != null && isFunction && value === Array.prototype[property]) {\r\n        return (...args) => batch(() => Array.prototype[property].apply(receiver, args));\r\n      }\r\n    }\r\n    return isWrappable(value) ? wrap(value) : value;\r\n  },\r\n  has(target, property) {\r\n    if (\r\n      property === $RAW ||\r\n      property === $PROXY ||\r\n      property === $TRACK ||\r\n      property === $NODE ||\r\n      property === $HAS ||\r\n      property === \"__proto__\"\r\n    )\r\n      return true;\r\n    getListener() && getNode(getNodes(target, $HAS), property)();\r\n    return property in target;\r\n  },\r\n  set(target, property, value) {\r\n    batch(() => setProperty(target, property, unwrap(value)));\r\n    return true;\r\n  },\r\n  deleteProperty(target, property) {\r\n    batch(() => setProperty(target, property, undefined, true));\r\n    return true;\r\n  },\r\n  ownKeys: ownKeys,\r\n  getOwnPropertyDescriptor: proxyDescriptor\r\n};\r\nfunction wrap(value) {\r\n  let p = value[$PROXY];\r\n  if (!p) {\r\n    Object.defineProperty(value, $PROXY, {\r\n      value: (p = new Proxy(value, proxyTraps))\r\n    });\r\n    const keys = Object.keys(value),\r\n      desc = Object.getOwnPropertyDescriptors(value);\r\n    const proto = Object.getPrototypeOf(value);\r\n    const isClass =\r\n      value !== null &&\r\n      typeof value === \"object\" &&\r\n      !Array.isArray(value) &&\r\n      proto !== Object.prototype;\r\n    if (isClass) {\r\n      const descriptors = Object.getOwnPropertyDescriptors(proto);\r\n      keys.push(...Object.keys(descriptors));\r\n      Object.assign(desc, descriptors);\r\n    }\r\n    for (let i = 0, l = keys.length; i < l; i++) {\r\n      const prop = keys[i];\r\n      if (isClass && prop === \"constructor\") continue;\r\n      if (desc[prop].get) {\r\n        const get = desc[prop].get.bind(p);\r\n        Object.defineProperty(value, prop, {\r\n          get,\r\n          configurable: true\r\n        });\r\n      }\r\n      if (desc[prop].set) {\r\n        const og = desc[prop].set,\r\n          set = v => batch(() => og.call(p, v));\r\n        Object.defineProperty(value, prop, {\r\n          set,\r\n          configurable: true\r\n        });\r\n      }\r\n    }\r\n  }\r\n  return p;\r\n}\r\nfunction createMutable(state, options) {\r\n  const unwrappedStore = unwrap(state || {});\r\n  if (typeof unwrappedStore !== \"object\" && typeof unwrappedStore !== \"function\")\r\n    throw new Error(\r\n      `Unexpected type ${typeof unwrappedStore} received when initializing 'createMutable'. Expected an object.`\r\n    );\r\n  const wrappedStore = wrap(unwrappedStore);\r\n  DEV$1.registerGraph({\r\n    value: unwrappedStore,\r\n    name: options && options.name\r\n  });\r\n  return wrappedStore;\r\n}\r\nfunction modifyMutable(state, modifier) {\r\n  batch(() => modifier(unwrap(state)));\r\n}\r\n\r\nconst $ROOT = Symbol(\"store-root\");\r\nfunction applyState(target, parent, property, merge, key) {\r\n  const previous = parent[property];\r\n  if (target === previous) return;\r\n  const isArray = Array.isArray(target);\r\n  if (\r\n    property !== $ROOT &&\r\n    (!isWrappable(target) ||\r\n      !isWrappable(previous) ||\r\n      isArray !== Array.isArray(previous) ||\r\n      (key && target[key] !== previous[key]))\r\n  ) {\r\n    setProperty(parent, property, target);\r\n    return;\r\n  }\r\n  if (isArray) {\r\n    if (\r\n      target.length &&\r\n      previous.length &&\r\n      (!merge || (key && target[0] && target[0][key] != null))\r\n    ) {\r\n      let i, j, start, end, newEnd, item, newIndicesNext, keyVal;\r\n      for (\r\n        start = 0, end = Math.min(previous.length, target.length);\r\n        start < end &&\r\n        (previous[start] === target[start] ||\r\n          (key && previous[start] && target[start] && previous[start][key] === target[start][key]));\r\n        start++\r\n      ) {\r\n        applyState(target[start], previous, start, merge, key);\r\n      }\r\n      const temp = new Array(target.length),\r\n        newIndices = new Map();\r\n      for (\r\n        end = previous.length - 1, newEnd = target.length - 1;\r\n        end >= start &&\r\n        newEnd >= start &&\r\n        (previous[end] === target[newEnd] ||\r\n          (key && previous[start] && target[start] && previous[end][key] === target[newEnd][key]));\r\n        end--, newEnd--\r\n      ) {\r\n        temp[newEnd] = previous[end];\r\n      }\r\n      if (start > newEnd || start > end) {\r\n        for (j = start; j <= newEnd; j++) setProperty(previous, j, target[j]);\r\n        for (; j < target.length; j++) {\r\n          setProperty(previous, j, temp[j]);\r\n          applyState(target[j], previous, j, merge, key);\r\n        }\r\n        if (previous.length > target.length) setProperty(previous, \"length\", target.length);\r\n        return;\r\n      }\r\n      newIndicesNext = new Array(newEnd + 1);\r\n      for (j = newEnd; j >= start; j--) {\r\n        item = target[j];\r\n        keyVal = key && item ? item[key] : item;\r\n        i = newIndices.get(keyVal);\r\n        newIndicesNext[j] = i === undefined ? -1 : i;\r\n        newIndices.set(keyVal, j);\r\n      }\r\n      for (i = start; i <= end; i++) {\r\n        item = previous[i];\r\n        keyVal = key && item ? item[key] : item;\r\n        j = newIndices.get(keyVal);\r\n        if (j !== undefined && j !== -1) {\r\n          temp[j] = previous[i];\r\n          j = newIndicesNext[j];\r\n          newIndices.set(keyVal, j);\r\n        }\r\n      }\r\n      for (j = start; j < target.length; j++) {\r\n        if (j in temp) {\r\n          setProperty(previous, j, temp[j]);\r\n          applyState(target[j], previous, j, merge, key);\r\n        } else setProperty(previous, j, target[j]);\r\n      }\r\n    } else {\r\n      for (let i = 0, len = target.length; i < len; i++) {\r\n        applyState(target[i], previous, i, merge, key);\r\n      }\r\n    }\r\n    if (previous.length > target.length) setProperty(previous, \"length\", target.length);\r\n    return;\r\n  }\r\n  const targetKeys = Object.keys(target);\r\n  for (let i = 0, len = targetKeys.length; i < len; i++) {\r\n    applyState(target[targetKeys[i]], previous, targetKeys[i], merge, key);\r\n  }\r\n  const previousKeys = Object.keys(previous);\r\n  for (let i = 0, len = previousKeys.length; i < len; i++) {\r\n    if (target[previousKeys[i]] === undefined) setProperty(previous, previousKeys[i], undefined);\r\n  }\r\n}\r\nfunction reconcile(value, options = {}) {\r\n  const { merge, key = \"id\" } = options,\r\n    v = unwrap(value);\r\n  return state => {\r\n    if (!isWrappable(state) || !isWrappable(v)) return v;\r\n    const res = applyState(\r\n      v,\r\n      {\r\n        [$ROOT]: state\r\n      },\r\n      $ROOT,\r\n      merge,\r\n      key\r\n    );\r\n    return res === undefined ? state : res;\r\n  };\r\n}\r\nconst producers = new WeakMap();\r\nconst setterTraps = {\r\n  get(target, property) {\r\n    if (property === $RAW) return target;\r\n    const value = target[property];\r\n    let proxy;\r\n    return isWrappable(value)\r\n      ? producers.get(value) ||\r\n          (producers.set(value, (proxy = new Proxy(value, setterTraps))), proxy)\r\n      : value;\r\n  },\r\n  set(target, property, value) {\r\n    setProperty(target, property, unwrap(value));\r\n    return true;\r\n  },\r\n  deleteProperty(target, property) {\r\n    setProperty(target, property, undefined, true);\r\n    return true;\r\n  }\r\n};\r\nfunction produce(fn) {\r\n  return state => {\r\n    if (isWrappable(state)) {\r\n      let proxy;\r\n      if (!(proxy = producers.get(state))) {\r\n        producers.set(state, (proxy = new Proxy(state, setterTraps)));\r\n      }\r\n      fn(proxy);\r\n    }\r\n    return state;\r\n  };\r\n}\r\n\r\nconst DEV = {\r\n  $NODE,\r\n  isWrappable,\r\n  hooks: DevHooks\r\n};\r\n\r\nexport { $RAW, DEV, createMutable, createStore, modifyMutable, produce, reconcile, unwrap };\r\n"],
  "mappings": "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",
  "names": ["DEV"]
}
